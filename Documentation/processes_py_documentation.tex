\documentclass[11pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{mdframed}

% Page geometry
\geometry{margin=1in}

% Colors
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.97,0.97,0.95}
\definecolor{warningbg}{RGB}{255,243,205}
\definecolor{warningborder}{RGB}{255,234,167}

% Listings configuration
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue}\bfseries,
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\small,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    frame=single,
    rulecolor=\color{black!30}
}
\lstset{style=mystyle}

% Header/Footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\texttt{processes.py} Documentation}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

% Section formatting
\titleformat{\section}{\large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection}{1em}{}

% Warning box
\newmdenv[
    linecolor=warningborder,
    backgroundcolor=warningbg,
    linewidth=1pt,
    roundcorner=3pt,
    innertopmargin=10pt,
    innerbottommargin=10pt,
    innerrightmargin=10pt,
    innerleftmargin=10pt
]{warningbox}

% Title
\title{\textbf{\texttt{processes.py} Documentation}\\\large Process Management and JSON Persistence Module}
\author{}
\date{\today}

\begin{document}

\maketitle
\thispagestyle{empty}

% AI Warning
\begin{warningbox}
\textbf{Warning:} This documentation was generated by an AI assistant. However I have reviewed this file and made changes accordingly if needed. 
\end{warningbox}

\vspace{1em}

\begin{abstract}
\noindent\texttt{processes.py} is a Python module designed for process management with JSON persistence capabilities. It provides three core classes: \texttt{Mindmap} for process relationship mapping, \texttt{TimeStamp} for temporal tracking with disruptions, and \texttt{Process} for comprehensive process management with automatic instance tracking and O(1) lookup by unique identifier.
\end{abstract}

\tableofcontents
\newpage

%==============================================================================
\section{Overview}
%==============================================================================

The \texttt{processes.py} module implements a process management system with the following key features:

\begin{itemize}
    \item \textbf{Automatic Instance Tracking}: Uses \texttt{weakref.WeakSet} to track all created \texttt{Process} instances without manual registration
    \item \textbf{O(1) UID Lookup}: Dictionary-based JSON storage enables constant-time process retrieval
    \item \textbf{Temporal Disruption Handling}: \texttt{TimeStamp} class supports nested disruptions (pauses, async interruptions)
    \item \textbf{Merge-based Storage}: \texttt{storeAll()} preserves existing data while updating changed processes
    \item \textbf{Graph-based Relationships}: \texttt{Mindmap} class maps process dependencies and connections
\end{itemize}

%==============================================================================
\section{Dependencies}
%==============================================================================

The module requires only Python standard library modules:

\begin{lstlisting}[language=Python]
import random    # For UID generation
import json      # For persistence
import weakref   # For automatic instance tracking
import os        # For file operations
\end{lstlisting}

%==============================================================================
\section{Class Reference}
%==============================================================================

%------------------------------------------------------------------------------
\subsection{Mindmap}
%------------------------------------------------------------------------------

The \texttt{Mindmap} class implements a directed graph structure for mapping process relationships.

\subsubsection{Constructor}

\begin{lstlisting}[language=Python]
class Mindmap:
    def __init__(self, map: dict):
        """
        A mindmap can map the schematics of a process. 
        The map dictionary includes nodes (process names) 
        and edges (connections between nodes).
        """
        self.map = map
\end{lstlisting}

\subsubsection{Methods}

\begin{table}[h]
\centering
\begin{tabular}{@{}llp{6cm}@{}}
\toprule
\textbf{Method} & \textbf{Returns} & \textbf{Description} \\
\midrule
\texttt{nodes()} & \texttt{dict\_keys} & Returns all node names in the mindmap \\
\texttt{edges()} & \texttt{dict\_values} & Returns all edge connections \\
\texttt{connections(node)} & \texttt{list} & Returns nodes connected to given source node \\
\texttt{connected(src, node)} & \texttt{bool} & Checks if two nodes are connected \\
\texttt{connect(src, node, direction)} & \texttt{None} & Creates connection with optional directionality \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Connection Direction}

The \texttt{connect()} method supports three connection types via the \texttt{direction} parameter:

\begin{itemize}
    \item \texttt{direction=None}: Bidirectional connection (both nodes reference each other)
    \item \texttt{direction=False}: Source to node (srcNode $\rightarrow$ node)
    \item \texttt{direction=True}: Node to source (node $\rightarrow$ srcNode)
\end{itemize}

%------------------------------------------------------------------------------
\subsection{TimeStamp}
%------------------------------------------------------------------------------

The \texttt{TimeStamp} class handles temporal tracking with support for nested disruptions.

\subsubsection{Constructor}

\begin{lstlisting}[language=Python]
class TimeStamp:
    def __init__(self, _init: int, _term: int, _dis=None):
        """
        _init: time of initiation (Unix timestamp)
        _term: time of termination (Unix timestamp, -1 = ongoing)
        _dis: disruptions dict {"type": TimeStamp}
        """
        self.ts = {"initialized": _init, "terminated": _term}
        self.ts["disruptions"] = []
    
        if _dis is not None:
            for i in _dis:
                self.ts["disruptions"].append({i: _dis[i]})
\end{lstlisting}

\subsubsection{Instance Methods}

\begin{table}[h]
\centering
\begin{tabular}{@{}llp{7cm}@{}}
\toprule
\textbf{Method} & \textbf{Returns} & \textbf{Description} \\
\midrule
\texttt{add\_disruption(type, ts)} & \texttt{None} & Adds a disruption TimeStamp to this timestamp \\
\texttt{serialize\_disruptions()} & \texttt{list} & Converts disruptions to JSON-serializable format \\
\texttt{to\_hirearchial\_dict()} & \texttt{dict} & Returns complete timeline dictionary \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Static Methods}

\begin{lstlisting}[language=Python]
@staticmethod
def de_serialize(dis: list) -> dict:
    """
    Reconstructs TimeStamp objects from JSON disruption list.
    Returns dict of {disruption_type: TimeStamp}.
    """
\end{lstlisting}

%------------------------------------------------------------------------------
\subsection{Process}
%------------------------------------------------------------------------------

The \texttt{Process} class extends \texttt{TimeStamp} with process management capabilities and automatic instance tracking.

\subsubsection{Class-Level Instance Tracking}

\begin{lstlisting}[language=Python]
class Process(TimeStamp):
    __instances = weakref.WeakSet()
    # Automatically tracks all Process instances
\end{lstlisting}

The \texttt{weakref.WeakSet} ensures:
\begin{itemize}
    \item Automatic registration in \texttt{\_\_init\_\_}
    \item No memory leaks (weak references allow garbage collection)
    \item No manual tracking required
\end{itemize}

\subsubsection{Constructor}

\begin{lstlisting}[language=Python]
def __init__(self, name: str, layer: int, _init: int, _term: int, _dis=None):
    """
    name: Process name/identifier
    layer: Hierarchical layer (0 = parallel processing allowed)
    _init: Start time (Unix timestamp)
    _term: End time (-1 = ongoing)
    _dis: Disruptions dictionary
    
    Auto-generates UID: "{layer}-{4-digit-hex}"
    Auto-registers to __instances
    """
\end{lstlisting}

\subsubsection{Instance Methods}

\begin{table}[h]
\centering
\begin{tabular}{@{}llp{6cm}@{}}
\toprule
\textbf{Method} & \textbf{Returns} & \textbf{Description} \\
\midrule
\texttt{to\_hirearchial\_dict()} & \texttt{dict} & Full process dictionary with timeline \\
\texttt{to\_storage\_dict()} & \texttt{tuple} & (uid, dict) for dict storage \\
\texttt{write(ofile)} & \texttt{str} & Save/update single process to JSON \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Class Methods}

\begin{table}[h]
\centering
\begin{tabular}{@{}llp{7cm}@{}}
\toprule
\textbf{Method} & \textbf{Returns} & \textbf{Description} \\
\midrule
\texttt{load\_dict(data)} & \texttt{Process} & Create Process from dictionary \\
\texttt{storeAll(ofile)} & \texttt{str} & Merge all instances to JSON file \\
\texttt{loadAll(ofile)} & \texttt{list} & Load all processes from file \\
\texttt{load(uid, ofile)} & \texttt{Process|None} & O(1) lookup by UID \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Static Methods}

\begin{lstlisting}[language=Python]
@staticmethod
def get_layer_from_uid(uid: str) -> int:
    """Extracts layer number from UID format 'layer-hex'"""
    # Example: "1-a3f2" -> 1

@staticmethod
def remove(uid: str, ofile: str) -> bool:
    """Remove process by UID from storage"""

@staticmethod
def clear_storage(ofile: str) -> None:
    """Clear all processes from storage"""
\end{lstlisting}

%==============================================================================
\section{JSON Storage Format}
%==============================================================================

The module uses a dictionary-based JSON structure for O(1) UID lookup:

\begin{lstlisting}[language=json]
{
  "processes": {
    "1-a3f2": {
      "name": "Training",
      "uid": "1-a3f2",
      "timeline": {
        "initialized": 1000,
        "terminated": 5000,
        "disruptions": [
          {
            "pause": {
              "initialized": 2000,
              "terminated": 2500
            }
          }
        ]
      }
    },
    "2-b7c9": {
      "name": "Validation",
      "uid": "2-b7c9",
      "timeline": {
        "initialized": 6000,
        "terminated": -1,
        "disruptions": []
      }
    }
  }
}
\end{lstlisting}

\textbf{Key Design Decision:} Using UID as dictionary key enables $O(1)$ lookup vs $O(n)$ list iteration.

%==============================================================================
\section{Usage Examples}
%==============================================================================

\subsection{Creating and Saving Processes}

\begin{lstlisting}[language=Python]
from processes import Process, TimeStamp

# Create processes (auto-tracked)
p1 = Process("Training", layer=1, _init=0, _term=100)
p2 = Process("Validation", layer=2, _init=100, _term=200)

# Add disruption
pause = TimeStamp(50, 75)
p1.add_disruption("pause", pause)

# Save single process
p1.write("processes.json")

# Save all tracked instances
Process.storeAll("processes.json")
\end{lstlisting}

\subsection{Loading Processes}

\begin{lstlisting}[language=Python]
# O(1) lookup by UID
p = Process.load("1-a3f2", "processes.json")
if p:
    print(f"Found: {p.name}")

# Load all processes
all_processes = Process.loadAll("processes.json")

# Load from dictionary (for custom processing)
data = {"name": "Test", "uid": "1-1234", 
        "timeline": {"initialized": 0, "terminated": 100}}
p = Process.load_dict(data)
\end{lstlisting}

\subsection{Removing Processes}

\begin{lstlisting}[language=Python]
# Remove single process
success = Process.remove("1-a3f2", "processes.json")

# Clear all storage
Process.clear_storage("processes.json")
\end{lstlisting}

\subsection{Using Mindmap for Dependencies}

\begin{lstlisting}[language=Python]
from processes import Mindmap

# Create process dependency map
mindmap = Mindmap({
    "DataLoading": [],
    "Preprocessing": ["DataLoading"],
    "Training": ["Preprocessing"],
    "Validation": ["Training"]
})

# Check dependencies
print(mindmap.connections("Training"))  # ["Preprocessing"]
print(mindmap.connected("DataLoading", "Training"))  # False
\end{lstlisting}

%==============================================================================
\section{Method Reference by Category}
%==============================================================================

\subsection{Serialization}

\begin{itemize}
    \item \texttt{TimeStamp.serialize\_disruptions()} $\rightarrow$ JSON-serializable disruption list
    \item \texttt{TimeStamp.to\_hirearchial\_dict()} $\rightarrow$ Complete timeline dict
    \item \texttt{Process.to\_hirearchial\_dict()} $\rightarrow$ Complete process dict
    \item \texttt{Process.to\_storage\_dict()} $\rightarrow$ (uid, dict) tuple
\end{itemize}

\subsection{Deserialization}

\begin{itemize}
    \item \texttt{TimeStamp.de\_serialize(list)} $\rightarrow$ \texttt{\{type: TimeStamp\}} dict
    \item \texttt{Process.load\_dict(dict)} $\rightarrow$ \texttt{Process} instance
\end{itemize}

\subsection{Persistence}

\begin{itemize}
    \item \texttt{Process.write(ofile)} $\rightarrow$ Save/update single process
    \item \texttt{Process.storeAll(ofile)} $\rightarrow$ Merge all instances to file
    \item \texttt{Process.loadAll(ofile)} $\rightarrow$ Load all as list
    \item \texttt{Process.load(uid, ofile)} $\rightarrow$ O(1) lookup
    \item \texttt{Process.remove(uid, ofile)} $\rightarrow$ Remove by UID
    \item \texttt{Process.clear\_storage(ofile)} $\rightarrow$ Clear all
\end{itemize}

%==============================================================================
\section{Notes and Limitations}
%==============================================================================

\begin{itemize}
    \item \textbf{Thread Safety:} File operations are not atomic; concurrent writes may cause data loss
    \item \textbf{Memory Management:} \texttt{WeakSet} auto-removes unreferenced instances from tracking
    \item \textbf{UID Collisions:} 4-digit hex provides 65536 combinations; collision probability low but non-zero
    \item \textbf{JSON Limitations:} All timestamps stored as integers (Unix epoch)
    \item \textbf{Disruption Nesting:} Disruptions can contain disruptions recursively
\end{itemize}

\end{document}
